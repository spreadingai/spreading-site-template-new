import {
  InstanceType,
  NavBarItem,
  NavBarItemType,
  SidebarItem,
  SidebarItemType,
  Sidebars,
} from "./types";
import LibControllerImpl from "./index";
import path from "path";
import fs from "fs";
import { convertDocID, ignoreNumberPrefix, removeMdxSuffix } from "./utils";
import {
  DEFAULT_INSTANCE_ID,
  SEQUENCE_PREFIX_REGEX,
  IGNORE_FILE_NAME,
  IGNORE_FOLDER_NAME,
  ENTITY_ROOT_DIRECTORY,
} from "./constants";

class SidebarsController {
  static _instance: SidebarsController;
  _sidebarsMap: Record<string, Record<string, Sidebars>> = {};
  _usedSidebarIdsMap: Record<string, string[]> = {};
  static getInstance() {
    return (
      SidebarsController._instance ||
      (SidebarsController._instance = new SidebarsController())
    );
  }
  getSidebars(instanceID: string, docVersion?: string) {
    if (
      process.env.NODE_ENV !== "development" &&
      this._sidebarsMap[instanceID] &&
      this._sidebarsMap[instanceID][docVersion]
    ) {
      // console.log(`[SidebarsController]getSidebars cache`);
      return this._sidebarsMap[instanceID][docVersion];
    }
    let result: Sidebars = null;

    // Old Logic
    // let rootUrl = `${ENTITY_ROOT_DIRECTORY}/${
    //   instanceID === DEFAULT_INSTANCE_ID ? "" : instanceID + "_"
    // }docs`;
    // let newRootUrl = `${ENTITY_ROOT_DIRECTORY}/docs${
    //   instanceID === DEFAULT_INSTANCE_ID ? "" : "_" + instanceID
    // }`;
    // if (docVersion) {
    //   rootUrl = `${ENTITY_ROOT_DIRECTORY}/${
    //     instanceID === DEFAULT_INSTANCE_ID ? "" : instanceID + "_"
    //   }versioned_docs/version-${docVersion}`;
    //   newRootUrl = `${ENTITY_ROOT_DIRECTORY}/docs_${
    //     instanceID === DEFAULT_INSTANCE_ID ? "" : instanceID + "_"
    //   }versioned/version-${docVersion}`;
    // }

    // New logic: Use the path of the instance directly
    const targetInstance = LibControllerImpl.getInstances(
      InstanceType.Normal
    ).find((instance) => instance.id === instanceID);
    const temp = targetInstance.path.split("/");
    const instanceFolder = temp.slice(0, temp.length - 1).join("/");
    let rootUrl = `${ENTITY_ROOT_DIRECTORY}/${
      instanceID === DEFAULT_INSTANCE_ID
        ? ""
        : (instanceFolder ? instanceFolder + "/" : "") + instanceID + "_"
    }docs`;
    let newRootUrl = `${ENTITY_ROOT_DIRECTORY}/${
      instanceID === DEFAULT_INSTANCE_ID
        ? "docs"
        : (instanceFolder ? instanceFolder + "/" : "") + "docs_" + instanceID
    }`;
    if (docVersion) {
      rootUrl = `${ENTITY_ROOT_DIRECTORY}/${
        instanceID === DEFAULT_INSTANCE_ID
          ? ""
          : (instanceFolder ? instanceFolder + "/" : "") + instanceID + "_"
      }versioned_docs/version-${docVersion}`;
      newRootUrl = `${ENTITY_ROOT_DIRECTORY}/${
        instanceID === DEFAULT_INSTANCE_ID
          ? "docs_"
          : (instanceFolder ? instanceFolder + "/" : "") +
            "docs_" +
            instanceID +
            "_"
      }versioned/version-${docVersion}`;
    }

    let rootPath = path.resolve("./public", "..", rootUrl);
    const newRootPath = path.resolve("./public", "..", newRootUrl);

    // Compatible prefixes and suffixes
    if (fs.existsSync(newRootPath)) {
      rootPath = newRootPath;
      rootUrl = newRootUrl;
    }
    if (fs.existsSync(rootPath)) {
      const sidebarsUrl = `${rootUrl}/sidebars.json`;
      const sidebarsPath = path.resolve("./public", "..", sidebarsUrl);
      if (fs.existsSync(sidebarsPath)) {
        let sidebarsObj: Sidebars = JSON.parse(
          fs.readFileSync(sidebarsPath, "utf8")
        );
        if (Array.isArray(sidebarsObj)) {
          sidebarsObj = {
            mySidebar: JSON.parse(JSON.stringify(sidebarsObj)),
          };
        }
        Object.keys(sidebarsObj).forEach((key) => {
          this.transSidebarItem(rootUrl, sidebarsObj[key]);
        });
        result = sidebarsObj;
      } else {
        // No is generated by directory by default
        const defaultSidebar = {
          mySidebar: this.generatedSidebar(rootUrl, "."),
        };
        result = defaultSidebar;
      }
    } else {
      console.error(
        `[DocsController]getSidebars: The document directory for the instance was not found `,
        instanceID
      );
    }
    this._sidebarsMap = this._sidebarsMap || {};
    this._sidebarsMap[instanceID] = this._sidebarsMap[instanceID] || {};
    this._sidebarsMap[instanceID][docVersion] = result;
    // console.log(`[SidebarsController]getSidebars`);
    return this._sidebarsMap[instanceID][docVersion];
  }
  getUsedSidebarIds(instanceID: string) {
    if (this._usedSidebarIdsMap[instanceID]) {
      // console.log(`[SidebarsController]getUsedSidebarIds cache`);
      return JSON.parse(JSON.stringify(this._usedSidebarIdsMap[instanceID]));
    }
    const { themeConfig } = LibControllerImpl.getDocuoConfig();
    if (!themeConfig) return []; // 容错
    const { navbar } = themeConfig;
    const usedSidebarIds = [];
    const loop = (items: NavBarItem[] = [], usedSidebarIds: string[]) => {
      if (items.length === 0) return;
      for (const item of items) {
        !item.docsInstanceId && (item.docsInstanceId = DEFAULT_INSTANCE_ID);
        if (
          item.type === NavBarItemType.DocSidebar &&
          item.docsInstanceId === instanceID
        ) {
          usedSidebarIds.push(...(item.sidebarIds || [item.sidebarId]));
        }
        if (item.items) {
          loop(item.items, usedSidebarIds);
        }
      }
    };
    loop(navbar.items || [], usedSidebarIds);
    // Remove duplicate elements
    this._usedSidebarIdsMap[instanceID] = usedSidebarIds.reduce(
      (prev, curr) => {
        if (!prev.includes(curr)) {
          prev.push(curr);
        }
        return prev;
      },
      []
    );
    return JSON.parse(JSON.stringify(this._usedSidebarIdsMap[instanceID]));
  }
  getSidebarItemIDByMdxFileID(sidebars: Sidebars, mdxFileID: string) {
    const sidebarIds = Object.keys(sidebars);
    return sidebarIds.find((sidebarId) => {
      const sidebarItem = sidebars[sidebarId];
      const str = JSON.stringify(sidebarItem);
      if (
        str.includes(`"id": "${mdxFileID}"`) ||
        str.includes(`"id":"${mdxFileID}"`)
      ) {
        return true;
      } else {
        return false;
      }
    });
  }
  generatedSidebar(rootUrl: string, dirName: string) {
    // The dirName is the real path, and the number prefix is not removed
    // Only the url and id were removed from the prefix
    const dirPath = path.resolve("./public", "..", rootUrl, dirName);
    const loop = (dirPath: string): SidebarItem => {
      if (!fs.existsSync(dirPath)) {
        return null;
      }
      const stats = fs.statSync(dirPath);
      if (!stats.isDirectory()) {
        const relativePath = path.relative(rootUrl, dirPath);
        const parsedPath = path.parse(relativePath);
        if (
          parsedPath.ext.toLocaleLowerCase() === ".mdx" ||
          parsedPath.ext.toLocaleLowerCase() === ".md"
        ) {
          const originID = path.join(parsedPath.dir, parsedPath.name);
          const id = convertDocID(path.normalize(originID));
          return {
            type: SidebarItemType.Doc,
            id: ignoreNumberPrefix(id),
            label: ignoreNumberPrefix(parsedPath.name),
          };
        } else {
          return null;
        }
      }
      const files = fs.readdirSync(dirPath);
      const sidebar: SidebarItem = {
        type: SidebarItemType.Category,
        label: ignoreNumberPrefix(
          path.basename(dirPath, path.extname(dirPath))
        ),
        items: [],
      };

      this.sortFiles(files).forEach((file) => {
        if (
          !IGNORE_FILE_NAME.includes(file) &&
          !IGNORE_FOLDER_NAME.includes(file)
        ) {
          const filePath = path.join(dirPath, file);
          const childTreeData = loop(filePath);
          childTreeData &&
            ((childTreeData.items && childTreeData.items.length) ||
              !childTreeData.items) &&
            sidebar.items.push(childTreeData);
        }
      });
      return sidebar;
    };
    const result = loop(dirPath) as SidebarItem;
    const sidebar = result ? result.items : [];
    return sidebar;
  }
  transSidebarItem(rootUrl: string, sidebar: (string | SidebarItem)[]) {
    const loop = (items: (string | SidebarItem)[]) => {
      for (let index = 0; index < items.length; index++) {
        let sidebarItem = items[index];
        if (typeof sidebarItem === "string") {
          // Remove mdx|md suffix
          sidebarItem = removeMdxSuffix(sidebarItem);
          sidebarItem = convertDocID(path.normalize(sidebarItem));
          items[index] = {
            type: SidebarItemType.Doc,
            id: sidebarItem,
            label: path.basename(sidebarItem),
          };
        } else {
          const abbreviationKey = this.isAbbreviation(sidebarItem);
          if (abbreviationKey) {
            sidebarItem.type = SidebarItemType.Category;
            sidebarItem.label = abbreviationKey;
            sidebarItem.items = sidebarItem[abbreviationKey];
            sidebarItem.collapsible = true;
            sidebarItem.collapsed = true;
          }
          if (sidebarItem.type === SidebarItemType.Autogenerated) {
            const temp = this.generatedSidebar(rootUrl, sidebarItem.dirName);
            items.splice(index, 1, ...temp);
            index += temp.length - 1;
          } else {
            if (sidebarItem.id) {
              // Remove mdx|md suffix
              sidebarItem.id = removeMdxSuffix(sidebarItem.id);
              sidebarItem.id = convertDocID(path.normalize(sidebarItem.id));
            }
            if (sidebarItem.items) {
              loop(sidebarItem.items);
            }
          }
        }
      }
    };
    loop(sidebar);
  }
  isAbbreviation(sidebarItem: SidebarItem) {
    // Restriction 1: There is only one key-value pair
    // Restriction 2: Values must be arrays
    const keys = Object.keys(sidebarItem);
    const key = keys[0];
    const result =
      keys.length === 1 &&
      key !== "id" &&
      key !== "type" &&
      Array.isArray(sidebarItem[key]);
    return result ? key : "";
  }
  sortFiles(files: string[]) {
    const numberFiles = files.filter((item) =>
      SEQUENCE_PREFIX_REGEX.test(item)
    );
    const otherFiles = files.filter(
      (item) => !SEQUENCE_PREFIX_REGEX.test(item)
    );
    numberFiles.sort((a, b) => {
      return Number(a.split("-")[0]) - Number(b.split("-")[0]);
    });
    return numberFiles.concat(otherFiles);
  }
}
export default SidebarsController.getInstance();
